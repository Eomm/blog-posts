# What is AST?

You may have seen the term "AST" in multiple contexts, without digging into what it actually means.
It is a common term in compiler theory, and it is also used in the context of static analysis.
In this post, we will see what an AST is, and we will focus on how it is a key part of the JavaScript language and ecosystem.


## Abstract Syntax Tree

The AST acronym stands for **Abstract Syntax Tree**.
It is a tree data structure that represents any structured text file, so, every standardized syntax can be represented by an AST.  

Usually, the AST is generated to process source code files, but it can be generated from any text file such as Markdown, JSON file, or even a GraphQL Document!

Since the AST is "abstract", it does not have a standard representation since every language may have its own specific dictionary.  
However, the common concept that is shared across all the ASTs, is the tree rapresentation where the first node describes the file's entry point.

### How the AST is used

Generally, the first step to run a piece of software is to parse the source code and build an AST.
This operation is called **parsing** and it is performed by the **parser** component.

If the parser is unable to parse the source code, it will throw an error:
it means that the source code is not valid and the AST cannot be generated nor executed.

When the parser build a valid AST, the AST is forwarded to the **compiler**.
The compiler can do multiple operations by manipulating the AST such as:

- remove unnecessary code (unused variables, comments, etc.)
- transform the code to a lower level language to execute it

But the AST is not only used by compilers.  

We can parse the source code as well to enhance the developer experience and to provide additional features such as:

- code completion
- code refactoring
- code formatting
- code checking (_aka: linting_)

All these features are possible thanks to the AST tree representation of the source code!
This is how our IDE and powerful editors implements extraordinary features to improve the developer experience.


## How to generate a JavaScript AST

Let's focus on the **Node.js** runtime, and let's see how the AST is built.

JavaScript is a dynamic language, and it is not compiled, but it is interpreted.
Regardless of the fact that it is not compiled, as we said previously:
the first step for every high level programming language is to parse the source code and build an AST.  
Without completing this step, our code will never be executed.

In fact, if you try to run a JS file that contains invalid JavaScript code, the runtime will throw a `Syntax error` even if the function is never called.

```js
function foo() {
  ~ this is not javascript code! ~
}
```

Running `node index.js` will throw the error:

```sh
  ~ this is not javascript code! ~
         ^^

SyntaxError: Unexpected identifier
```

Under the hood, Node.js relies on the [Google V8 engine](https://v8.dev/) to parse the source code and build the AST.
The tree representation is then passed to the [Ignition interpreter](https://v8.dev/docs/ignition) that builds the final bytecode.

The AST generated by V8 is not accessible from the JavaScript code, but it is possible to generate an
AST from a JavaScript using one of the many available libraries:

- [`acorn`](https://www.npmjs.com/package/acorn)
- [`esprima`](https://www.npmjs.com/package/esprima)
- [`espree`](https://www.npmjs.com/package/espree)
- ...and a [lot more](https://www.npmjs.com/search?q=keywords:ast)

For example, the following code:

```js
function hello (name) {
  console.log('Hello ' + name)
}

hello('foo')
```

It can be represented by the following AST:

<div style="max-height: 150px; overflow: scroll">

```json
{
  "type": "Program",
  "start": 0,
  "end": 70,
  "body": [
    {
      "type": "FunctionDeclaration",
      "start": 0,
      "end": 56,
      "id": {
        "type": "Identifier",
        "start": 9,
        "end": 14,
        "name": "hello"
      },
      "expression": false,
      "generator": false,
      "async": false,
      "params": [
        {
          "type": "Identifier",
          "start": 16,
          "end": 20,
          "name": "name"
        }
      ],
      "body": {
        "type": "BlockStatement",
        "start": 22,
        "end": 56,
        "body": [
          {
            "type": "ExpressionStatement",
            "start": 26,
            "end": 54,
            "expression": {
              "type": "CallExpression",
              "start": 26,
              "end": 54,
              "callee": {
                "type": "MemberExpression",
                "start": 26,
                "end": 37,
                "object": {
                  "type": "Identifier",
                  "start": 26,
                  "end": 33,
                  "name": "console"
                },
                "property": {
                  "type": "Identifier",
                  "start": 34,
                  "end": 37,
                  "name": "log"
                },
                "computed": false,
                "optional": false
              },
              "arguments": [
                {
                  "type": "BinaryExpression",
                  "start": 38,
                  "end": 53,
                  "left": {
                    "type": "Literal",
                    "start": 38,
                    "end": 46,
                    "value": "Hello ",
                    "raw": "'Hello '"
                  },
                  "operator": "+",
                  "right": {
                    "type": "Identifier",
                    "start": 49,
                    "end": 53,
                    "name": "name"
                  }
                }
              ],
              "optional": false
            }
          }
        ]
      }
    },
    {
      "type": "ExpressionStatement",
      "start": 58,
      "end": 70,
      "expression": {
        "type": "CallExpression",
        "start": 58,
        "end": 70,
        "callee": {
          "type": "Identifier",
          "start": 58,
          "end": 63,
          "name": "hello"
        },
        "arguments": [
          {
            "type": "Literal",
            "start": 64,
            "end": 69,
            "value": "foo",
            "raw": "'foo'"
          }
        ],
        "optional": false
      }
    }
  ],
  "sourceType": "module"
}
```

</div>

### The AST standard initiative

In the initial section, we said that the AST is not standardized.  
Moreover, the AST generated by v8 is a [tuned and optimized AST](https://v8.dev/blog/scanner) designed for its engine so it is [tailor-made AST](https://groups.google.com/g/v8-users/c/_WracRX9BTQ?pli=1).

As mentioned before, there are many libraries that can generate an AST from a JavaScript source code.
At this point, the [**ESTree**](https://github.com/estree) community organization defines an (unofficial) standard for JavaScript ASTs.

However, there is a [nice story](https://github.com/estree/estree#the-estree-spec) behind the JavaScript AST structure baseline:

> Once upon a time, an [unsuspecting Mozilla engineer](http://calculist.org) created an API in Firefox that exposed the SpiderMonkey engine's JavaScript parser as a JavaScript API. Said engineer [documented the format it produced](https://web.archive.org/web/20210314002546/https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API), and this format caught on as a lingua franca for tools that manipulate JavaScript source code.

The specification maintained by the ESTree community follows the [ECMAScript standard](https://tc39.es/ecma262/) and its naming conventions.


### Famous ASTs

In the Node.js ecosystem, there are two famous modules that build an AST:

- `eslint`: the JS linting tool that spot errors and code smells
- `graphql`: the GraphQL query language that parse GQL schema and queries to let us implement a GraphQL server

A very useful tool to explore the AST is [AST Explorer](https://astexplorer.net/).  
You can copy-paste the source code and see the AST generated by the selected parser.

> ℹ️ Navigate the AST  
> I find it very useful to explore the AST generated by a graphql schema when I need to implement a [`mercurius` plugin](https://github.com/Eomm/mercurius-logging/)!


## Summary

I hope this AST post was useful to understand how the AST is used in the JavaScript ecosystem.

Now you should see your IDE and the `eslint` tool with different eyes!
There were no magic, just a tree data structure!

If you are willing to build an `eslint` or `graphql` plugin, the information in this post will
help you to start your journey!

If you enjoyed this article, comment, share, and follow me on [Twitter @ManuEomm](https://twitter.com/ManuEomm)!
